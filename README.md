## Test Task for Elixir LiveView Developers

The candidate should build a simple polling application using Phoenix LiveView. The application should allow users to create new polls, vote in polls, and see real-time updates of the poll results. The solution must use an SQL database as storage to persist users, polls and poll results. You are free to use any Elixir/Erlang library and any open-source CSS framework for the design.

### Requirements

1. All code should be shared via private Github repository.
2. The solution should be built with Phoenix LiveView.
3. The solution should use database as a persistent storage.
4. Users should be able to create account by inserting their username.
5. Users should be able to create new polls.
6. Users should be able to vote in existing polls.
7. Users should be able to see real-time updates of the poll results.
8. User can only vote once in a single poll.
10. You are free to use any Elixir/Erlang library and any open-source CSS framework for the UI.
12. The application should start with `mix phx.server` so it can be started locally.
13. The application should be well-structured, and the code should be readable.
14. The database should be set up with Docker and should be started with docker-compose.

### Deliverables

Please provide a link to a GitHub repository containing your solution to the above task. Your solution should include:

1. A Phoenix LiveView application that meets the above requirements.
2. A README file that explains how to set up and run the application. This includes any kind of set up instructions required for the database.
3. Clear and concise documentation on how the application works, including any design decisions you made and any trade-offs you considered.
4. Well-structured code that adheres to best practices and is easy to understand and modify.
5. The core business functionality of the application must be covered by unit tests.

### Evaluation Criteria

We will evaluate your solution based on the following criteria:

1. Functionality: Does your application meet all the requirements listed above?
2. Code quality: Is your code well-structured and easy to understand and modify? Does it adhere to best practices?
3. Design decisions: Did you make thoughtful and well-reasoned design decisions? Did you consider trade-offs and explain your reasoning?
4. Documentation: Is your README file clear and comprehensive? Does it include instructions for setting up and running the application? Does your documentation explain how the application works and any design decisions you made?
5. Unit testing: Does your solution include unit tests that cover core business functionality?

Good luck!
